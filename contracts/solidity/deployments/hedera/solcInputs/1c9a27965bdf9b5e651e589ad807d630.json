{
  "language": "Solidity",
  "sources": {
    "contracts/GreenDAO.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\nimport \"./lib/Strings.sol\";\r\n\r\n\r\ncontract GreenDAO {\r\n    struct dao_uri_struct {\r\n        string dao_wallet;\r\n        string dao_uri;\r\n        string finished;\r\n    }\r\n    struct goal_uri_struct {\r\n        uint256 dao_id;\r\n        string goal_uri;\r\n    }\r\n\r\n    struct ideas_uri_struct {\r\n        uint256 goal_id;\r\n        string ideas_uri;\r\n        uint256 donation;\r\n    }\r\n\r\n    struct donation_struct {\r\n        uint256 ideas_id;\r\n        string wallet;\r\n        uint256 donation;\r\n    }\r\n\r\n    struct smart_contract_uri_struct {\r\n        uint256 smart_contract_id;\r\n        uint256 ideas_id;\r\n        string smart_contract_uri;\r\n    }\r\n    struct goal_ideas_votes_struct {\r\n        uint256 goal_id;\r\n        uint256 ideas_id;\r\n        string wallet;\r\n    }\r\n    struct message_struct {\r\n        uint256 message_id;\r\n        uint256 ideas_id;\r\n        string message;\r\n        string sender;\r\n    }\r\n    struct message_read_struct {\r\n        uint256 message_id;\r\n        uint256 ideas_id;\r\n        string wallet;\r\n        string msg_type;\r\n    }\r\n    struct reply_struct {\r\n        uint256 reply_id;\r\n        uint256 message_id;\r\n        uint256 ideas_id;\r\n        string message;\r\n    }\r\n\r\n    struct UnbondingRequest {\r\n        int64 completionTime;\r\n        uint256 amount;\r\n    }\r\n\r\n    struct join_struct {\r\n        uint256 daoid;\r\n        string wallet;\r\n    }\r\n\r\n    struct user_badge_struct {\r\n        string wallet;\r\n        bool dao;\r\n        bool joined;\r\n        bool goal;\r\n        bool ideas;\r\n        bool vote;\r\n        bool donation;\r\n        bool comment;\r\n        bool reply;\r\n    }\r\n    uint256 public _dao_ids;\r\n    uint256 public _donations_ids;\r\n    uint256 public _goal_ids;\r\n    uint256 public _ideas_ids;\r\n    uint256 public _join_ids;\r\n    uint256 public _smart_contract_ids;\r\n    uint256 public _ideas_vote_ids;\r\n    uint256 public _message_ids;\r\n    uint256 public _message_read_ids;\r\n    uint256 public _reply_ids;\r\n    mapping(uint256 => dao_uri_struct) public _dao_uris; //_dao_ids              => (Dao)                    Dao Wallet + Dao URI   + Finished\r\n    mapping(uint256 => string) public _template_uris; //_dao_ids              => (Dao)                   Template HTML Code\r\n    mapping(uint256 => join_struct) public _joined_person; //_join_ids             => (Dao)                  join_struct\r\n\r\n    mapping(uint256 => goal_uri_struct) public _goal_uris; //_goal_ids             => (Goal)                   Dao ID + Goal URI\r\n    mapping(uint256 => ideas_uri_struct) public _ideas_uris; //_ideas_ids            => (Ideas)                  Goal ID + Ideas URI\r\n    mapping(string => uint256) public _donated; //string            => (Donated to ideas)                amount\r\n    mapping(uint256 => donation_struct) public _donations; //uint256            => donation_struct\r\n    mapping(uint256 => smart_contract_uri_struct) public _smart_contracts_uris; //_smart_contract_ids   => (Ideas Smart contract)   Goal ID + Ideas URI\r\n    mapping(uint256 => goal_ideas_votes_struct) public all_goal_ideas_votes; //_ideas_vote_ids       => (Vote)                   Goal ID + Ideas ID + Wallet\r\n\r\n    mapping(uint256 => message_struct) public all_messages; // all_messages        => _message_ids + message_struct\r\n\r\n    mapping(uint256 => message_read_struct) public all_read_messages; // all_read_messages        => _message_read_ids + message_read_struct\r\n\r\n    mapping(uint256 => reply_struct) public all_replies; // all_messages        => _reply_ids + reply_struct\r\n    mapping(string => user_badge_struct) public _user_badges; //string            => user_badge_struct\r\n\r\n    //Daos\r\n    function create_dao(string memory _dao_wallet, string memory _dao_uri, string memory _template) public returns (uint256) {\r\n        //Create Dao into _dao_uris\r\n        _dao_uris[_dao_ids] = dao_uri_struct(_dao_wallet, _dao_uri, 'False');\r\n        _template_uris[_dao_ids] = _template;\r\n        _user_badges[_dao_wallet].dao = true;\r\n        _dao_ids++;\r\n\r\n        return _dao_ids;\r\n    }\r\n\r\n    function update_template(uint256 _dao_id, string memory _template) public {\r\n        _template_uris[_dao_id] = _template;\r\n    }\r\n\r\n    function set_dao(uint256 _dao_id, string memory _dao_wallet, string memory _dao_uri) public {\r\n        //Set Dao of wallet and uri\r\n        _dao_uris[_dao_id].dao_wallet = _dao_wallet;\r\n        _dao_uris[_dao_id].dao_uri = _dao_uri;\r\n    }\r\n\r\n    function get_all_daos() public view returns (string[] memory) {\r\n        //Getting all doas\r\n        string[] memory _StoreInfo = new string[](_dao_ids);\r\n        for (uint256 i = 0; i < _dao_ids; i++) {\r\n            _StoreInfo[i] = _dao_uris[i].dao_uri;\r\n        }\r\n\r\n        return _StoreInfo;\r\n    }\r\n\r\n    function dao_uri(uint256 _dao_id) public view returns (string memory) {\r\n        //Getting one dao URI\r\n        return _dao_uris[_dao_id].dao_uri;\r\n    }\r\n\r\n    //Goals\r\n    function create_goal(string memory _goal_uri, uint256 _dao_id,string memory _wallet) public returns (uint256) {\r\n        //Create goal into _goal_uris\r\n        _goal_uris[_goal_ids] = goal_uri_struct(_dao_id, _goal_uri);\r\n        _user_badges[_wallet].goal = true;\r\n        _goal_ids++;\r\n\r\n        return _goal_ids;\r\n    }\r\n\r\n    function set_goal(uint256 _goal_id, string memory _goal_uri) public {\r\n        //Set goal uri\r\n        _goal_uris[_goal_id].goal_uri = _goal_uri;\r\n    }\r\n\r\n    function get_all_goals() public view returns (string[] memory) {\r\n        //Getting all goals\r\n        string[] memory _StoreInfo = new string[](_goal_ids);\r\n        for (uint256 i = 0; i < _goal_ids; i++) {\r\n            _StoreInfo[i] = _goal_uris[i].goal_uri;\r\n        }\r\n\r\n        return _StoreInfo;\r\n    }\r\n\r\n    function get_all_goals_by_dao_id(uint256 _dao_id) public view returns (string[] memory) {\r\n        //Getting all goals by dao id\r\n        string[] memory _StoreInfo = new string[](_goal_ids);\r\n        uint256 _store_id;\r\n        for (uint256 i = 0; i < _goal_ids; i++) {\r\n            if (_goal_uris[i].dao_id == _dao_id) {\r\n                _StoreInfo[_store_id] = _goal_uris[i].goal_uri;\r\n                _store_id++;\r\n            }\r\n        }\r\n\r\n        return _StoreInfo;\r\n    }\r\n\r\n    function get_goal_id_by_goal_uri(string memory _goal_uri) public view returns (uint256) {\r\n        //Getting goal id by uri\r\n        for (uint256 i = 0; i < _goal_ids; i++) {\r\n            if (keccak256(bytes(_goal_uris[i].goal_uri)) == keccak256(bytes(_goal_uri))) return i;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    function goal_uri(uint256 _goal_id) public view returns (string memory) {\r\n        //Getting one goal URI\r\n        return _goal_uris[_goal_id].goal_uri;\r\n    }\r\n\r\n    //Ideas\r\n    function create_ideas(string memory _ideas_uri, uint256 _goal_id, string[] memory _smart_contracts,string memory _wallet) public returns (uint256) {\r\n        //Create ideas into _ideas_uris\r\n        _ideas_uris[_ideas_ids] = ideas_uri_struct(_goal_id, _ideas_uri, 0);\r\n        _user_badges[_wallet].ideas = true;\r\n        _ideas_ids++;\r\n\r\n        for (uint256 i = 0; i < _smart_contracts.length; i++) {\r\n            create_ideas_smart_contract(_ideas_ids, _smart_contract_ids, _smart_contracts[i]);\r\n            _smart_contract_ids++;\r\n        }\r\n\r\n        return _ideas_ids;\r\n    }\r\n\r\n    function create_ideas_smart_contract(uint256 _ideas_id, uint256 _smart_contract_id, string memory _smart_contract) private {\r\n        _smart_contracts_uris[_smart_contract_id] = smart_contract_uri_struct(_ideas_id, _smart_contract_id, _smart_contract);\r\n    }\r\n\r\n    function set_ideas(uint256 _ideas_id, string memory _ideas_uri) public {\r\n        _ideas_uris[_ideas_id].ideas_uri = _ideas_uri;\r\n    }\r\n\r\n    function add_donation(uint256 _ideas_id, uint256 _doantion, string memory _donator) public {\r\n        _user_badges[_donator].donation = true;\r\n        _ideas_uris[_ideas_id].donation += _doantion;\r\n        _donated[_donator] += _doantion;\r\n        _donations[_donations_ids] = donation_struct(_ideas_id, _donator, _doantion);\r\n        _donations_ids++;\r\n    }\r\n\r\n    function join_community(uint256 dao_id, string memory person) public {\r\n        _user_badges[person].joined = true;\r\n        _joined_person[_join_ids] = join_struct({daoid: dao_id, wallet: person});\r\n        _join_ids++;\r\n    }\r\n\r\n    function is_person_joined(string memory wallet) public view returns (bool) {\r\n        //Getting goal id by uri\r\n        for (uint256 i = 0; i < _join_ids; i++) {\r\n            if (keccak256(bytes(_joined_person[i].wallet)) == keccak256(bytes(wallet))) return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function get_all_ideas() public view returns (string[] memory) {\r\n        //Getting all ideas\r\n        string[] memory _StoreInfo = new string[](_ideas_ids);\r\n        for (uint256 i = 0; i < _ideas_ids; i++) {\r\n            _StoreInfo[i] = _ideas_uris[i].ideas_uri;\r\n        }\r\n\r\n        return _StoreInfo;\r\n    }\r\n\r\n    function get_all_ideas_by_goal_id(uint256 _goal_id) public view returns (string[] memory) {\r\n        //Getting all ideas by goal id\r\n        string[] memory _StoreInfo = new string[](_ideas_ids);\r\n        uint256 _store_id;\r\n        for (uint256 i = 0; i < _ideas_ids; i++) {\r\n            if (_ideas_uris[i].goal_id == _goal_id) _StoreInfo[_store_id] = _ideas_uris[i].ideas_uri;\r\n            _store_id++;\r\n        }\r\n\r\n        return _StoreInfo;\r\n    }\r\n\r\n    function get_ideas_id_by_ideas_uri(string memory _ideas_uri) public view returns (uint256) {\r\n        //Getting ideas id by uri\r\n        for (uint256 i = 0; i < _ideas_ids; i++) {\r\n            if (keccak256(bytes(_ideas_uris[i].ideas_uri)) == keccak256(bytes(_ideas_uri))) return i;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    function get_goal_id_from_ideas_uri(string memory _ideas_uri) public view returns (uint256) {\r\n        //Getting ideas id by uri\r\n        for (uint256 i = 0; i < _ideas_ids; i++) {\r\n            if (keccak256(bytes(_ideas_uris[i].ideas_uri)) == keccak256(bytes(_ideas_uri))) return _ideas_uris[i].goal_id;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    function ideas_uri(uint256 _ideas_id) public view returns (string memory) {\r\n        //Getting one ideas URI\r\n        return _ideas_uris[_ideas_id].ideas_uri;\r\n    }\r\n\r\n    //Votes\r\n    function create_goal_ideas_vote(uint256 _goal_id, uint256 _ideas_id, string memory _wallet) public returns (uint256) {\r\n         _user_badges[_wallet].vote = true;\r\n        //Create votes into all_goal_ideas_votes\r\n        all_goal_ideas_votes[_ideas_vote_ids] = goal_ideas_votes_struct(_goal_id, _ideas_id, _wallet);\r\n        _ideas_vote_ids++;\r\n\r\n        return _ideas_vote_ids;\r\n    }\r\n\r\n    function get_ideas_votes_from_goal(uint256 _goal_id, uint256 _ideas_id) public view returns (string[] memory) {\r\n        //gets all ideas votes from goal\r\n        string[] memory _StoreInfo = new string[](_ideas_vote_ids);\r\n        uint256 _store_id;\r\n        for (uint256 i = 0; i < _ideas_vote_ids; i++) {\r\n            if (all_goal_ideas_votes[i].goal_id == _goal_id && all_goal_ideas_votes[i].ideas_id == _ideas_id) _StoreInfo[_store_id] = all_goal_ideas_votes[i].wallet;\r\n            _store_id++;\r\n        }\r\n        return _StoreInfo;\r\n    }\r\n\r\n    //Messages\r\n    function sendMsg(uint256 _ideas_id, string memory _message, string memory _sender) public returns (uint256) {\r\n            _user_badges[_sender].comment = true;\r\n        //Create messsage into all_messages\r\n        all_messages[_message_ids] = message_struct(_message_ids, _ideas_id, _message, _sender);\r\n        _message_ids++;\r\n\r\n        return _message_ids;\r\n    }\r\n\r\n    function getMsgIDs(uint256 ideas_id) public view returns (uint256[] memory) {\r\n        //Getting all messages ids by idea id\r\n        uint256[] memory _All_Ideas_Messages = new uint256[](_message_ids);\r\n        uint256 _msg_id;\r\n        for (uint256 i = 0; i < _message_ids; i++) {\r\n            if (all_messages[i].ideas_id == ideas_id) {\r\n                _All_Ideas_Messages[_msg_id] = all_messages[i].message_id;\r\n                _msg_id++;\r\n            }\r\n        }\r\n\r\n        return _All_Ideas_Messages;\r\n    }\r\n\r\n    function sendReply(uint256 _message_id, string memory _reply,uint256 ideas_id,string memory _wallet) public returns (uint256) {\r\n          _user_badges[_wallet].reply = true;\r\n        //Create reply into all_replies\r\n        all_replies[_reply_ids] = reply_struct(_reply_ids, _message_id,ideas_id, _reply);\r\n        _reply_ids++;\r\n\r\n        return _reply_ids;\r\n    }\r\n\r\n    function getReplyIDs(uint256 message_id) public view returns (uint256[] memory) {\r\n        //Getting all messages ids by idea id\r\n        uint256[] memory _All_Messages_Replys = new uint256[](_reply_ids);\r\n        uint256 _reply_id;\r\n        for (uint256 i = 0; i < _reply_ids; i++) {\r\n            if (all_replies[i].message_id == message_id) {\r\n                _All_Messages_Replys[_reply_id] = all_replies[i].reply_id;\r\n                _reply_id++;\r\n            }\r\n        }\r\n\r\n        return _All_Messages_Replys;\r\n    }\r\n\r\n    function sendReadMsg(uint256 _message_id, uint256 _ideas_id,string memory _wallet, string memory msg_type) public returns (uint256) {\r\n        //Create messsage into all_messages\r\n        all_read_messages[_message_read_ids] = message_read_struct(_message_id, _ideas_id, _wallet,msg_type);\r\n        _message_read_ids++;\r\n\r\n        return _message_read_ids;\r\n    }\r\n\r\n\r\n\r\n  function getReadMsg(uint256 _message_id, string memory msg_type)  public view returns (bool) {\r\n       \r\n       bool read = false;\r\n        for (uint256 i = 0; i < _message_read_ids; i++) {\r\n            if (all_read_messages[i].message_id == _message_id && keccak256(bytes(msg_type)) == keccak256(bytes(all_read_messages[i].msg_type))) {\r\n               read = true; \r\n            }\r\n        }\r\n\r\n        return read;\r\n    }\r\n\r\n\r\n\r\n    function reset_all() public {\r\n        for (uint256 i = 0; i < _dao_ids; i++) delete _dao_uris[i];\r\n        for (uint256 i = 0; i < _goal_ids; i++) delete _goal_uris[i];\r\n        for (uint256 i = 0; i < _ideas_ids; i++) delete _ideas_uris[i];\r\n        for (uint256 i = 0; i < _goal_ids; i++) delete _smart_contracts_uris[i];\r\n        for (uint256 i = 0; i < _message_ids; i++) delete all_messages[i];\r\n        for (uint256 i = 0; i < _reply_ids; i++) delete all_replies[i];\r\n        for (uint256 i = 0; i < _ideas_vote_ids; i++) delete all_goal_ideas_votes[i];\r\n        _dao_ids = 0;\r\n        _goal_ids = 0;\r\n        _ideas_ids = 0;\r\n        _message_ids = 0;\r\n        _reply_ids = 0;\r\n        _ideas_vote_ids = 0;\r\n    }\r\n\r\n    function addTempData() public {\r\n        create_dao(\r\n            '0x86bb6d6e18c5eeaca1e83c1e6162cc433dcc70a4',\r\n            '{\"title\":\"Asset Metadata\",\"type\":\"object\",\"properties\":{\"Title\":{\"type\":\"string\",\"description\":\"Lake Nona, Orlando US\"},\"Description\":{\"type\":\"string\",\"description\":\"\"},\"Start_Date\":{\"type\":\"string\",\"description\":\"2023-08-16T11:14\"},\"logo\":{\"type\":\"string\",\"description\":{\"url\":\"https://bafybeicb5yy36ocs4yulph6zpx7ggsyeginsjwnft7ml7cxojywpbsjuq4.ipfs.nftstorage.link\",\"type\":\"image/png\"}},\"wallet\":{\"type\":\"string\",\"description\":\"0x86bb6d6e18c5eeaca1e83c1e6162cc433dcc70a4\"},\"SubsPrice\":{\"type\":\"number\",\"description\":\"0.05\"},\"typeimg\":{\"type\":\"string\",\"description\":\"Dao\"},\"allFiles\":[{\"url\":\"https://bafybeicb5yy36ocs4yulph6zpx7ggsyeginsjwnft7ml7cxojywpbsjuq4.ipfs.nftstorage.link\",\"type\":\"image/png\"}]}}',\r\n            '<body><div id=\"dao-container\"><div class=\"dao-container flex items-center flex-col gap-8 relative\"><div class=\"dao-title gap-8 flex flex-col relative\"><div><h1 id=\"dao-title\" class=\"text-moon-32 font-bold\">Lake Nona, Orlando US</h1></div><div class=\"flex gap-4 justify-between tabs\"><div class=\"flex\"><a href=\"/?q=All\" class=\"DonationBarLink tab block px-3 py-2 active\">All</a><a href=\"/?q=Today\" class=\"DonationBarLink tab block px-3 py-2\">Today</a><a href=\"/?q=This%20Month\" class=\"DonationBarLink tab block px-3 py-2\">This Month</a></div><button type=\"button\" value=\"Create Goal\" class=\"py-2 px-4 gap-2 text-moon-14 rounded-moon-i-sm z-0 flex justify-center items-center font-medium no-underline overflow-hidden select-none outline-none transition duration-200 active:scale-90 focus-visible:shadow-focus btn-primary create-goal-block\"><div class=\"gap-2\" id=\"iqokj\">\\n       \\n      </div></button></div></div><div class=\"dao-divider\">\\n  </div><div class=\"flex flex-col gap-8\"><img id=\"dao-image\" src=\"https://bafybeicb5yy36ocs4yulph6zpx7ggsyeginsjwnft7ml7cxojywpbsjuq4.ipfs.nftstorage.link\"/></div><div id=\"goal-container\" class=\"flex flex-col gap-8\">\\n\\n  </div></div></div></body><style>* { box-sizing: border-box; } body {margin: 0;}#dao-title{width:78%;}#iqokj{flex-direction:row-reverse;display:flex;}.py-2.px-4.gap-2.text-moon-14.rounded-moon-i-sm.relative.z-0.flex.justify-center.items-center.font-medium.no-underline.overflow-hidden.select-none.outline-none.transition.duration-200.active\\\\:scale-90.focus-visible\\\\:shadow-focus.btn-primary.create-goal-block.{position:relative;right:0px;}.py-2.px-4.gap-2.text-moon-14.rounded-moon-i-sm.z-0.flex.justify-center.items-center.font-medium.no-underline.overflow-hidden.select-none.outline-none.transition.duration-200.active\\\\:scale-90.focus-visible\\\\:shadow-focus.btn-primary.create-goal-block.{right:10px;position:absolute;}</style>'\r\n        );\r\n        create_goal('{\"title\":\"Asset Metadata\",\"type\":\"object\",\"properties\":{\"Title\":{\"type\":\"string\",\"description\":\"Renewable energy\"},\"Description\":{\"type\":\"string\",\"description\":\"Our DAO is starting it\\'s own renewable energy company that delivers energy for the whole community\"},\"Budget\":{\"type\":\"string\",\"description\":\"$1,000,000\"},\"End_Date\":{\"type\":\"string\",\"description\":\"2023-08-31T22:40\"},\"wallet\":{\"type\":\"string\",\"description\":\"0x86bb6d6e18c5eeaca1e83c1e6162cc433dcc70a4\"},\"logo\":{\"type\":\"string\",\"description\":{\"url\":\"https://bafybeic5g4xvj7myrgkb62lenld7orpl2hrspmzlzcdbzpyotc33tqygpe.ipfs.nftstorage.link\",\"type\":\"image/jpeg\"}},\"allFiles\":[{\"url\":\"https://bafybeic5g4xvj7myrgkb62lenld7orpl2hrspmzlzcdbzpyotc33tqygpe.ipfs.nftstorage.link\",\"type\":\"image/jpeg\"}]}}', 0, '0x86bb6d6e18c5eeaca1e83c1e6162cc433dcc70a4');\r\n        string[] memory row;\r\n        create_ideas('{\"title\":\"Asset Metadata\",\"type\":\"object\",\"properties\":{\"Title\":{\"type\":\"string\",\"description\":\"Solar panels on the Consequences Nona community center \"},\"Description\":{\"type\":\"string\",\"description\":\"We can ins\\\\n\"},\"StructureLeft\":{\"type\":\"string\",\"description\":[\"Representatives Berlin\",\"Community\",\"Children\"]},\"StructureRight\":{\"type\":\"string\",\"description\":[\"20%\",\"70%\",\"10%\"]},\"Qoutation\":{\"link\":\"https://uploadify.net/5273d350dfd001d1/quotation_Consequences_Nona_community_center.pdf\",\"prize\":\"$48,071.55\"},\"wallet\":{\"type\":\"string\",\"description\":\"0xD60bC0b00c1D8a718FB6fDeDc4466c7A1180868c\"},\"logo\":{\"type\":\"string\",\"description\":{\"url\":\"https://bafybeif4fk6twikkcyopglhppdo7dd3l34bm6qedje3mxftec5e7b4he54.ipfs.nftstorage.link\",\"type\":\"image/png\"}},\"allFiles\":[{\"url\":\"https://bafybeif4fk6twikkcyopglhppdo7dd3l34bm6qedje3mxftec5e7b4he54.ipfs.nftstorage.link\",\"type\":\"image/png\"}]}}', 0, row, '0x86bb6d6e18c5eeaca1e83c1e6162cc433dcc70a4');\r\n    }\r\n}\r\n"
    },
    "contracts/lib/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.0 (utils/Strings.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}